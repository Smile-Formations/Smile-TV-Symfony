## Overview

### Operations in Doctrine are handled by different mechanisms:

- The EntityManager is the main entrypoint for entities
  - Its UnitOfWork keeps track of any changes in the entities, new or known ones
  - It commits the requests once a flush is asked and the changes are calculated
- The repositories handle the operations on your entities
  - Repositories provide an intermediate layer between your domain logic and data mapping
  - You can use them to write custom queries
  - Each defined entity in your application generally has its own repository

![6.4.1](../assets/06-Doctrine/4-Requests%20in%20database/6.4.1.png)

---

## New data

To save a new entity in the database to be written as a new line, your first have to make it known to the EntityManager. This operation is called `persist`.
You can then `flush` every waiting operation to actually save your entity in the database. This will give you access to the entity’s identifier (id).

With attributes (recommended):

```php
class BookController extends AbstractController
{
    //...
    
    #[Route('/create', name: 'book_creation', methods: ['GET'])]
    public function create(ObjectManager $manager): Response
    {
        $book = (new Book())
            ->setIsbn('0-86140-324-X')
            ->setTitle('The color of Magic')
        ;
        
        $manager->persist($book);
        $manager->flush();
        
        return $this->redirectToRoute('homepage');
    }
}
```

With annotations:

```php
use Symfony\Component\Routing\Annotation\Route;

class BookController extends AbstractController
{
    //...
    
    /**
     * @Route("/create", name="book_creation", methods={"GET"})
     */
    public function create(ObjectManager $manager): Response
    {
        $book = (new Book())
            ->setIsbn('0-86140-324-X')
            ->setTitle('The color of Magic')
        ;
        
        $manager->persist($book);
        $manager->flush();
        
        return $this->redirectToRoute('homepage');
    }
}
```

---

## Repositories

- Instead of using the EntityManager, you can use your entity’s Repository.
- Repositories are classes meant to store all operations relating to one specific type of entity.
- They contain a number of method stubs common to every repository.

Repository base methods:
- find methods:
  - `find($id)`, `findAll()`
  - `findBy`, `findOneBy` which take an array of criteria as arguments
  - `findBy{Property}`, `findOneBy{Property}` magic methods which take the criteria as argument
- `add` and `remove` (only with repositories generated by the MakerBundle) which take an optional boolean parameter `flush` (default `false`) 

Save an entity with attributes and repository:

```php
class BookController extends AbstractController
{
    #[Route('/create', name: 'book_creation', methods: ['GET'])]
    public function create(BookRepository $bookRepository): Response
    {
        $book = (new Book())
            ->setIsbn('0-86140-324-X')
            ->setTitle('The color of Magic')
        ;
        
        $bookRepository->save($book, true);
        
        return $this->redirectToRoute('homepage');
    }
}
```

## Retrieve data

With attributes (recommended):

```php
class BookController extends AbstractController
{
    #[Route('/list', name: 'book_list', methods: ['GET'])]
    public function all(BookRepository $bookRepository): Response
    {
        $books = $bookRepository->all();
        
        return $this->render('book/list.html.twig', [
            'books' => $books,
        ]);
    }
}
```

With annotations:

```php
use Symfony\Component\Routing\Annotation\Route;

class BookController extends AbstractController
{
    /**
     * @Route("/list", name="book_list", methods={"GET"})
     */
    public function all(BookRepository $bookRepository): Response
    {
        $books = $bookRepository->all();
        
        return $this->render('book/list.html.twig', [
            'books' => $books,
        ]);
    }
}
```

---

## Custom requests

If you need custom queries, you can write them in your repositories three different ways:

- In plain SQL
- Using Doctrine Query Language (DQL - language using objects)
- Using a Query Builder

## Custom DQL request

```php
class BookRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Book::class);
    }

    public function findBookWithAuthors(string $isbn): void
    {
        $dql = <<< DQL
            SELECT b, a
                FROM App\Entity\Book b
                JOIN b.authors a
                WHERE b.isbn = :isbn
        DQL;
        
        return $this->getEntityManager()
            ->createQuery($dql)
            ->setParameter('isbn', $isbn)
            ->getOneOrNullResult()
        ;
    }
}
```

## Alternatively: use a query builder 

```php
class BookRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Book::class);
    }

    public function findBookWithAuthors(string $isbn): void
    {
        return $this->createQueryBuilder('b')
            ->join(App\Entity\Author::class)
            ->setParameter('isbn', $isbn)
            ->getQuery()
            ->getOneOrNullResult()
        ;
    }
}
```

---

## Exercises

- Update your “app_movie_details” page to retrieve movies from your database.
- Create a back office for movies with `make:crud` (tip: generate it in the `Controller\Admin` namespace).
- (optional) Update the last section of your homepage to pick only 6 newest movies from your database.
